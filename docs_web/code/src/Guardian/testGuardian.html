<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>src.Guardian.testGuardian API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="icon" href="https://s3-eu-west-1.amazonaws.com/jonatan.enes.udc/serverless_containers_website/icon_serverless.png">
<style>
.footer_image {
max-width: 25%;
float: left;
padding: 1%;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.Guardian.testGuardian</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2019 Universidade da Coruña
# Authors:
#     - Jonatan Enes [main](jonatan.enes@udc.es, jonatan.enes.alvarez@gmail.com)
#     - Roberto R. Expósito
#     - Juan Touriño
#
# This file is part of the ServerlessContainers framework, from
# now on referred to as ServerlessContainers.
#
# ServerlessContainers is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# ServerlessContainers is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with ServerlessContainers. If not, see &lt;http://www.gnu.org/licenses/&gt;.


import random
import unittest
import time

from test.documents.rules import cpu_exceeded_upper, cpu_dropped_lower, mem_exceeded_upper, mem_dropped_lower, \
    CpuRescaleUp, energy_exceeded_upper, CpuRescaleDown, MemRescaleUp, MemRescaleDown, EnergyRescaleUp, \
    EnergyRescaleDown, energy_dropped_lower
from test.documents.services import guardian_service as guardian
from src.Guardian.Guardian import CPU_SHARES_PER_WATT, NOT_AVAILABLE_STRING
from src.MyUtils import MyUtils
from src.MyUtils.MyUtils import generate_event_name
from unittest import TestCase
from src.Guardian import Guardian
from src.StateDatabase.couchdb import CouchDBServer
from src.StateDatabase.opentsdb import OpenTSDBServer


class GuardianTest(TestCase):
    def setUp(self):
        self.guardian = Guardian.Guardian()

    def test_check_invalid_values(self):

        # An error should be thrown
        with self.assertRaises(ValueError):
            self.guardian.check_invalid_values(20, &#34;label1&#34;, 10, &#34;label2&#34;)

        # Nothing should happen
        TestCase.assertEqual(self, first=None, second=self.guardian.check_invalid_values(10, &#34;label1&#34;, 20, &#34;label2&#34;))

    def test_check_unset_values(self):
        # An error should be thrown
        with self.assertRaises(ValueError):
            self.guardian.check_unset_values(NOT_AVAILABLE_STRING, &#34;min&#34;, &#34;cpu&#34;)

            # Nothing should happen
            self.guardian.check_unset_values(1, &#34;min&#34;, &#34;cpu&#34;)

    def test_try_get_value(self):
        TestCase.assertEqual(self, first=1, second=self.guardian.try_get_value({&#34;KEY&#34;: 1}, &#34;KEY&#34;))
        TestCase.assertEqual(self, first=NOT_AVAILABLE_STRING,
                             second=self.guardian.try_get_value({&#34;KEY&#34;: 1}, &#34;NOKEY&#34;))

    def test_generate_event_name(self):
        scale_down = {&#34;scale&#34;: {&#34;down&#34;: 5}}
        scale_up = {&#34;scale&#34;: {&#34;up&#34;: 2}}

        TestCase.assertEqual(self, first=&#34;CpuUnderuse&#34;, second=generate_event_name(scale_down, &#34;cpu&#34;))
        TestCase.assertEqual(self, first=&#34;MemUnderuse&#34;, second=generate_event_name(scale_down, &#34;mem&#34;))
        TestCase.assertEqual(self, first=&#34;DiskUnderuse&#34;, second=generate_event_name(scale_down, &#34;disk&#34;))
        TestCase.assertEqual(self, first=&#34;NetUnderuse&#34;, second=generate_event_name(scale_down, &#34;net&#34;))

        TestCase.assertEqual(self, first=&#34;CpuBottleneck&#34;, second=generate_event_name(scale_up, &#34;cpu&#34;))
        TestCase.assertEqual(self, first=&#34;MemBottleneck&#34;, second=generate_event_name(scale_up, &#34;mem&#34;))
        TestCase.assertEqual(self, first=&#34;DiskBottleneck&#34;, second=generate_event_name(scale_up, &#34;disk&#34;))
        TestCase.assertEqual(self, first=&#34;NetBottleneck&#34;, second=generate_event_name(scale_up, &#34;net&#34;))

        scale_invalid1 = {&#34;bogus&#34;: 1}
        scale_invalid2 = {&#34;scale&#34;: {&#34;bogus&#34;: 1}}

        with self.assertRaises(ValueError):
            generate_event_name(scale_invalid1, &#34;cpu&#34;)

        with self.assertRaises(ValueError):
            generate_event_name(scale_invalid2, &#34;cpu&#34;)

    def test_filter_old_events(self):
        all_events = list()
        timeout = 20

        for i in range(0, 5):
            now = time.time()
            ago = now - timeout - 4
            all_events.append({&#34;timestamp&#34;: now})
            all_events.append({&#34;timestamp&#34;: ago})

        valid, invalid = self.guardian.sort_events(all_events, timeout)

        TestCase.assertEqual(self, first=5, second=len(invalid))
        TestCase.assertEqual(self, first=5, second=len(valid))

    def test_reduce_structure_events(self):
        input_events = list()
        for i in range(1, 5):
            input_events.append({&#34;resource&#34;: &#34;cpu&#34;, &#34;action&#34;: {&#34;events&#34;: {&#34;scale&#34;: {&#34;up&#34;: i, &#34;down&#34;: 0}}}})

        for i in range(2, 6):
            input_events.append({&#34;resource&#34;: &#34;cpu&#34;, &#34;action&#34;: {&#34;events&#34;: {&#34;scale&#34;: {&#34;up&#34;: 0, &#34;down&#34;: i}}}})

        expected_output = {&#34;cpu&#34;: {&#34;events&#34;: {&#34;scale&#34;: {&#34;up&#34;: sum(range(1, 5)), &#34;down&#34;: sum(range(2, 6))}}}}

        TestCase.assertEqual(self, first=expected_output, second=self.guardian.reduce_structure_events(input_events))

    def test_correct_container_state(self):
        def get_valid_state():
            resources_dict = dict(
                cpu=dict(max=300, current=170, min=50),
                mem=dict(max=8192, current=4096, min=256)
            )

            limits_dict = dict(
                cpu=dict(upper=140, lower=110, boundary=30),
                mem=dict(upper=3072, lower=2048, boundary=1024)

            )
            return resources_dict, limits_dict

        # State should be valid
        resources, limits = get_valid_state()
        TestCase.assertEqual(self, first=limits,
                             second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

        # Make resources and limits invalid because invalid boundary
        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            resources, limits = get_valid_state()
            # Upper too close to current
            limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - int(limits[resource][&#34;boundary&#34;] / 2)
            TestCase.assertEqual(self, first=limits,
                                 second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

            # Upper too far away to current
            limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - limits[resource][&#34;boundary&#34;] * 2
            TestCase.assertEqual(self, first=limits,
                                 second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

            # Lower too close to upper
            limits[resource][&#34;lower&#34;] = limits[resource][&#34;upper&#34;] - int(limits[resource][&#34;boundary&#34;] / 2)
            TestCase.assertEqual(self, first=limits,
                                 second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

            # Lower too far away to upper
            limits[resource][&#34;lower&#34;] = limits[resource][&#34;upper&#34;] - limits[resource][&#34;boundary&#34;] * 2
            TestCase.assertEqual(self, first=limits,
                                 second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

    def test_invalid_container_state(self):
        def get_valid_state():
            resources_dict = dict(
                cpu=dict(max=300, current=170, min=50),
                mem=dict(max=8192, current=4096, min=256)
            )

            limits_dict = dict(
                cpu=dict(upper=140, lower=110, boundary=30),
                mem=dict(upper=3072, lower=2048, boundary=1024)

            )
            return resources_dict, limits_dict

        # State should be valid
        resources, limits = get_valid_state()
        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            self.assertFalse(self.guardian.check_invalid_container_state(resources, limits, resource))

        # Make resources and limits invalid because unset
        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            for key in [(&#34;max&#34;, &#34;resource&#34;), (&#34;min&#34;, &#34;resource&#34;), (&#34;upper&#34;, &#34;limit&#34;), (&#34;lower&#34;, &#34;limit&#34;)]:
                label, doc_type = key
                resources, limits = get_valid_state()
                if doc_type == &#34;limit&#34;:
                    limits[resource][label] = NOT_AVAILABLE_STRING
                if doc_type == &#34;resource&#34;:
                    resources[resource][label] = NOT_AVAILABLE_STRING
                with self.assertRaises(ValueError):
                    self.guardian.check_invalid_container_state(resources, limits, resource)

        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            # Invalid because max &lt; current
            resources, limits = get_valid_state()
            resources[resource][&#34;max&#34;], resources[resource][&#34;current&#34;] = \
                resources[resource][&#34;current&#34;], resources[resource][&#34;max&#34;]
            with self.assertRaises(ValueError):
                self.guardian.check_invalid_container_state(resources, limits, resource)

            # Invalid because current &lt; upper
            resources, limits = get_valid_state()
            resources[resource][&#34;current&#34;], limits[resource][&#34;upper&#34;] = \
                limits[resource][&#34;upper&#34;], resources[resource][&#34;current&#34;]
            with self.assertRaises(ValueError):
                self.guardian.check_invalid_container_state(resources, limits, resource)

            # Invalid because upper &lt; lower
            resources, limits = get_valid_state()
            limits[resource][&#34;upper&#34;], limits[resource][&#34;lower&#34;] = limits[resource][&#34;lower&#34;], limits[resource][&#34;upper&#34;]
            with self.assertRaises(ValueError):
                self.guardian.check_invalid_container_state(resources, limits, resource)

            # Invalid because lower &lt; min
            # TODO Test deactivated, see TODO in tested function
            # resources, limits = get_valid_state()
            # resources[resource][&#34;min&#34;], limits[resource][&#34;lower&#34;] = \
            #     limits[resource][&#34;lower&#34;], resources[resource][&#34;min&#34;]
            # with self.assertRaises(ValueError):
            #     self.guardian.check_invalid_container_state(resources, limits, resource)

        # Make resources and limits invalid because invalid boundary
        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            resources, limits = get_valid_state()
            # Upper too close to current
            limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - int(limits[resource][&#34;boundary&#34;] / 2)
            with self.assertRaises(ValueError):
                self.guardian.check_invalid_container_state(resources, limits, resource)
            # Upper too far away to current
            limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - limits[resource][&#34;boundary&#34;] * 2
            with self.assertRaises(ValueError):
                self.guardian.check_invalid_container_state(resources, limits, resource)

            # resources, limits = get_valid_state()
            # # Lower too close to upper
            # limits[resource][&#34;lower&#34;] = limits[resource][&#34;upper&#34;] - limits[resource][&#34;boundary&#34;] / 2
            # with self.assertRaises(ValueError):
            #     guardian.invalid_container_state(resources, limits)
            # # Lower too far away to upper
            # limits[resource][&#34;lower&#34;] = limits[resource][&#34;upper&#34;] - limits[resource][&#34;boundary&#34;] * 2
            # with self.assertRaises(ValueError):
            #     guardian.invalid_container_state(resources, limits)

    def test_get_container_resources_str(self):

        resources_dict = dict(
            cpu=dict(max=300, current=200, min=50),
            mem=dict(max=8192, current=2048, min=256),
            disk=dict(max=200, current=80, min=50),
            net=dict(max=200, current=80, min=50)
        )

        limits_dict = dict(
            cpu=dict(upper=140, lower=70, boundary=70),
            mem=dict(upper=8000, lower=7000, boundary=1000),
            disk=dict(upper=70, lower=60),
            net=dict(upper=70, lower=60)
        )

        usages_dict = {
            &#34;structure.cpu.usage&#34;: 22.5664364,
            &#34;structure.mem.usage&#34;: 2341.9734,
        }

        TestCase.assertEqual(self, first=&#34;300,200,140,22.57,70,50&#34;,
                             second=self.guardian.get_resource_summary(&#34;cpu&#34;, resources_dict, limits_dict,
                                                                       usages_dict))
        TestCase.assertEqual(self, first=&#34;8192,2048,8000,2341.97,7000,256&#34;,
                             second=self.guardian.get_resource_summary(&#34;mem&#34;, resources_dict, limits_dict,
                                                                       usages_dict))

    def test_container_energy_str(self):
        resources_dict = dict(
            energy=dict(max=50, usage=20, min=0)
        )

        TestCase.assertEqual(self, first=&#34;50,20,0&#34;, second=self.guardian.get_container_energy_str(resources_dict))

    def test_adjust_if_invalid_amount(self):
        structure_resources = {&#34;max&#34;: 400, &#34;min&#34;: 50, &#34;current&#34;: 200}
        structure_limits = {&#34;upper&#34;: 150, &#34;lower&#34;: 100}

        # Correct cases
        TestCase.assertEqual(self, first=70,
                             second=self.guardian.adjust_amount(70, structure_resources, structure_limits))
        TestCase.assertEqual(self, first=100,
                             second=self.guardian.adjust_amount(100, structure_resources, structure_limits))

        # Over the max
        TestCase.assertEqual(self, first=200,
                             second=self.guardian.adjust_amount(250, structure_resources, structure_limits))
        TestCase.assertEqual(self, first=200,
                             second=self.guardian.adjust_amount(260, structure_resources, structure_limits))

        # Correct cases
        TestCase.assertEqual(self, first=-10,
                             second=self.guardian.adjust_amount(-10, structure_resources, structure_limits))
        TestCase.assertEqual(self, first=-50,
                             second=self.guardian.adjust_amount(-50, structure_resources, structure_limits))

        # Under the minimum
        TestCase.assertEqual(self, first=-50,
                             second=self.guardian.adjust_amount(-60, structure_resources, structure_limits))
        TestCase.assertEqual(self, first=-50,
                             second=self.guardian.adjust_amount(-100, structure_resources, structure_limits))

        structure_resources = {&#34;max&#34;: 40, &#34;min&#34;: 5, &#34;current&#34;: 20}
        structure_limits = {&#34;upper&#34;: 15, &#34;lower&#34;: 10}
        TestCase.assertEqual(self, first=10,
                             second=self.guardian.adjust_amount(10, structure_resources, structure_limits))

    def test_get_amount_from_percentage_reduction(self):
        resource = &#34;mem&#34;
        structure = {&#34;resources&#34;: {&#34;mem&#34;: {&#34;max&#34;: 4096, &#34;min&#34;: 280, &#34;current&#34;: 2000}}}
        usages = {&#34;structure.mem.usage&#34;: 700}

        TestCase.assertEqual(self, first=-260,
                             second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 20))
        TestCase.assertEqual(self, first=-520,
                             second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 40))

        TestCase.assertEqual(self, first=-650,
                             second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 50))

        # Should max out at 50%
        TestCase.assertEqual(self, first=-650,
                             second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 70))

    def test_get_amount_from_proportional_energy_rescaling(self):
        resource = &#34;energy&#34;

        def check():
            data = structure[&#34;resources&#34;][&#34;energy&#34;]
            expected = (data[&#34;max&#34;] - data[&#34;usage&#34;]) * CPU_SHARES_PER_WATT
            TestCase.assertEqual(self, first=expected,
                                 second=self.guardian.get_amount_from_proportional_energy_rescaling(structure,
                                                                                                    resource))

        structure = {&#34;resources&#34;: {&#34;energy&#34;: {&#34;max&#34;: 60, &#34;min&#34;: 10, &#34;usage&#34;: 30}}}
        check()
        structure = {&#34;resources&#34;: {&#34;energy&#34;: {&#34;max&#34;: 60, &#34;min&#34;: 10, &#34;usage&#34;: 80}}}
        check()

    def test_get_amount_from_fit_reduction(self):
        current_resource_limit = 2000
        current_resource_usage = 700
        boundary = 500

        # To properly fit the limit, the usage (700) has to be placed between the upper and lower limit,
        # keeping the inter-limit boundary (500) so the new limits should be (950,450)
        # finally, keeping the real resource limit to the upper limit boundary (500), the final
        # current value to apply should be (upper limit)950 + 500(boundary) = 1450
        # so the amount to reduce is 2000 - 1450 = 550
        TestCase.assertEqual(self,
                             first=self.guardian.get_amount_from_fit_reduction(current_resource_limit, boundary,
                                                                               current_resource_usage),
                             second=-550)

    def test_match_usages_and_limits(self):
        def assert_event_equals(rule, ev):
            event_expected_name = generate_event_name(rule[&#34;action&#34;][&#34;events&#34;], rule[&#34;resource&#34;])
            self.assertTrue(event_expected_name, ev[&#34;name&#34;])
            self.assertTrue(structure_name, ev[&#34;structure&#34;])
            self.assertTrue(rule[&#34;action&#34;], ev[&#34;action&#34;])
            self.assertTrue(&#34;event&#34;, ev[&#34;type&#34;])
            self.assertTrue(rule[&#34;resource&#34;], ev[&#34;resource&#34;])

        mem_exceeded_upper[&#34;active&#34;] = True
        mem_dropped_lower[&#34;active&#34;] = True

        rules = [mem_exceeded_upper, mem_dropped_lower]
        structure_name = &#34;node99&#34;

        resources = dict(
            mem=dict(max=8192, current=4096, min=256, guard=True),
        )

        limits = dict(
            mem=dict(upper=2048, lower=1024),
        )
        usages = {&#34;structure.mem.usage&#34;: 1536}

        # No events expected
        TestCase.assertEqual(self, [],
                             second=self.guardian.match_usages_and_limits(structure_name, rules, usages, limits,
                                                                          resources))

        # Expect mem underuse event
        usages[&#34;structure.mem.usage&#34;] = limits[&#34;mem&#34;][&#34;lower&#34;] - 100
        events = self.guardian.match_usages_and_limits(structure_name, rules, usages, limits, resources)
        if not events:
            self.fail(&#34;No events were triggered when expected.&#34;)
        else:
            event = events[0]
            assert_event_equals(mem_dropped_lower, event)

        # Expect mem bottleneck event
        usages[&#34;structure.mem.usage&#34;] = limits[&#34;mem&#34;][&#34;upper&#34;] + 100
        events = self.guardian.match_usages_and_limits(structure_name, rules, usages, limits, resources)
        if not events:
            self.fail(&#34;No events were triggered when expected.&#34;)
        else:
            event = events[0]
            assert_event_equals(mem_dropped_lower, event)

    def test_match_rules_and_events(self):

        def get_valid_state():
            st = {
                &#34;guard&#34;: True,
                &#34;guard_policy&#34;: &#34;serverless&#34;,
                &#34;host&#34;: &#34;c14-13&#34;,
                &#34;host_rescaler_ip&#34;: &#34;c14-13&#34;,
                &#34;host_rescaler_port&#34;: &#34;8000&#34;,
                &#34;name&#34;: &#34;node0&#34;,
                &#34;resources&#34;: {
                    &#34;cpu&#34;: {
                        &#34;current&#34;: 140,
                        &#34;guard&#34;: True,
                        &#34;max&#34;: 200,
                        &#34;min&#34;: 50
                    },
                    &#34;energy&#34;: {
                        &#34;guard&#34;: False,
                        &#34;max&#34;: 20,
                        &#34;min&#34;: 0,
                        &#34;usage&#34;: 2.34
                    },
                    &#34;mem&#34;: {
                        &#34;current&#34;: 3072,
                        &#34;guard&#34;: True,
                        &#34;max&#34;: 10240,
                        &#34;min&#34;: 512
                    }
                },
                &#34;subtype&#34;: &#34;container&#34;,
                &#34;type&#34;: &#34;structure&#34;
            }
            lim = {&#34;cpu&#34;: {&#34;upper&#34;: 120, &#34;lower&#34;: 80, &#34;boundary&#34;: 20},
                   &#34;mem&#34;: {&#34;upper&#34;: 2048, &#34;lower&#34;: 1024, &#34;boundary&#34;: 1024},
                   &#34;energy&#34;: {&#34;upper&#34;: 20, &#34;lower&#34;: 10, &#34;boundary&#34;: 5},
                   }

            us = {&#34;structure.cpu.usage&#34;: 100, &#34;structure.mem.usage&#34;: 1536, &#34;structure.energy.usage&#34;: 15}

            return st, lim, us

        event_rules = [cpu_exceeded_upper, cpu_dropped_lower, mem_exceeded_upper, mem_dropped_lower,
                       energy_exceeded_upper, energy_dropped_lower]
        rescaling_rules = [CpuRescaleUp, CpuRescaleDown, MemRescaleUp, MemRescaleDown, EnergyRescaleUp,
                           EnergyRescaleDown]
        for rule in event_rules + rescaling_rules:
            rule[&#34;active&#34;] = True

        for tuple in [(&#34;cpu&#34;, CpuRescaleDown, -50), (&#34;mem&#34;, MemRescaleDown, -50), (&#34;cpu&#34;, CpuRescaleUp, 100),
                      (&#34;mem&#34;, MemRescaleUp, 2034)]:

            resource, rescale_rule, amount = tuple
            structure, limits, usages = get_valid_state()

            usages[&#34;structure.&#34; + resource + &#34;.usage&#34;] = limits[resource][&#34;lower&#34;] + amount
            events = list()

            num_needed_events = rescale_rule[&#34;rule&#34;][&#34;and&#34;][0][&#34;&gt;=&#34;][1]

            for i in range(num_needed_events):
                events += self.guardian.match_usages_and_limits(structure[&#34;name&#34;], event_rules, usages, limits,
                                                                structure[&#34;resources&#34;])
            events = self.guardian.reduce_structure_events(events)

            generated_requests, events_to_remove = self.guardian.match_rules_and_events(structure, rescaling_rules,
                                                                                        events, limits,
                                                                                        usages)

            expected_events_to_remove = dict()
            event_to_remove_name = MyUtils.generate_event_name(events[resource][&#34;events&#34;], resource)
            expected_events_to_remove[event_to_remove_name] = num_needed_events

            TestCase.assertEqual(self, first=expected_events_to_remove, second=events_to_remove)


class GuardianServelerssIntegrationTest(TestCase):

    def tearDown(self):
        self.couchdb.remove_database(&#34;services-test&#34;)
        self.couchdb.remove_database(&#34;structures-test&#34;)
        self.couchdb.remove_database(&#34;limits-test&#34;)
        self.couchdb.remove_database(&#34;rules-test&#34;)
        self.couchdb.remove_database(&#34;events-test&#34;)
        self.couchdb.remove_database(&#34;requests-test&#34;)
        self.couchdb.close_connection()
        self.opentsdb.close_connection()

    def setUp(self):
        def initialize_database(database_type, database_name):
            self.couchdb.set_database_name(database_type, database_name)
            if self.couchdb.database_exists(database_name):
                self.couchdb.remove_database(database_name)
            self.couchdb.create_database(database_name)

        self.couchdb = CouchDBServer(&#34;localhost&#34;, &#34;5984&#34;)
        self.opentsdb = OpenTSDBServer(&#34;localhost&#34;, &#34;4242&#34;)

        initialize_database(&#34;services&#34;, &#34;services-test&#34;)
        initialize_database(&#34;structures&#34;, &#34;structures-test&#34;)
        initialize_database(&#34;limits&#34;, &#34;limits-test&#34;)
        initialize_database(&#34;rules&#34;, &#34;rules-test&#34;)
        initialize_database(&#34;events&#34;, &#34;events-test&#34;)
        initialize_database(&#34;requests&#34;, &#34;requests-test&#34;)

        self.guardian = Guardian.Guardian()
        self.guardian.debug = False

        self.guardian.couchdb_handler = self.couchdb
        self.guardian.opentsdb_handler = self.opentsdb

    def test_serverless(self):
        guardian_service = guardian
        testing_node_name = &#34;testingNode{0}&#34;.format(str(random.randint(0, 10)))
        structure = {&#34;guard&#34;: True, &#34;guard_policy&#34;: &#34;serverless&#34;, &#34;host&#34;: &#34;c14-13&#34;, &#34;host_rescaler_ip&#34;: &#34;c14-13&#34;,
                     &#34;host_rescaler_port&#34;: &#34;8000&#34;,
                     &#34;resources&#34;: {
                         &#34;cpu&#34;: {
                             &#34;current&#34;: 140,
                             &#34;guard&#34;: True,
                             &#34;max&#34;: 200,
                             &#34;min&#34;: 50
                         },
                         &#34;energy&#34;: {
                             &#34;guard&#34;: True,
                             &#34;max&#34;: 20,
                             &#34;min&#34;: 0,
                             &#34;usage&#34;: 2.34
                         },
                         &#34;mem&#34;: {
                             &#34;current&#34;: 3072,
                             &#34;guard&#34;: True,
                             &#34;max&#34;: 10240,
                             &#34;min&#34;: 512
                         }
                     }, &#34;subtype&#34;: &#34;container&#34;, &#34;type&#34;: &#34;structure&#34;, &#34;name&#34;: testing_node_name}

        limits = {&#34;type&#34;: &#34;limit&#34;, &#34;resources&#34;: {&#34;cpu&#34;: {&#34;upper&#34;: 120, &#34;lower&#34;: 80, &#34;boundary&#34;: 20},
                                                 &#34;mem&#34;: {&#34;upper&#34;: 2048, &#34;lower&#34;: 1024, &#34;boundary&#34;: 1024},
                                                 &#34;energy&#34;: {&#34;upper&#34;: 20, &#34;lower&#34;: 10, &#34;boundary&#34;: 10}
                                                 }, &#34;name&#34;: testing_node_name}

        event_rules = [cpu_exceeded_upper, cpu_dropped_lower, mem_exceeded_upper, mem_dropped_lower]
        rescaling_rules = [CpuRescaleUp, CpuRescaleDown, MemRescaleUp, MemRescaleDown]
        for rule in event_rules + rescaling_rules:
            rule[&#34;active&#34;] = True

        guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] = 20
        guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] = 100 + random.randint(0, 100)
        guardian_service[&#34;config&#34;][&#34;EVENT_TIMEOUT&#34;] = 100

        # Add the guardian service, a structure
        self.couchdb.add_service(guardian_service)
        guardian_service = self.couchdb.get_service(&#34;guardian&#34;)
        self.couchdb.add_structure(structure)

        # Check that without usage data, nothing is donde
        structure[&#34;guard&#34;] = True
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))

        # Check that without limits, nothing is done
        structure[&#34;guard&#34;] = True
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))

        # Add the limits and rules
        self.couchdb.add_limit(limits)
        for rule in event_rules + rescaling_rules:
            self.couchdb.add_rule(rule)

        time.sleep(2)  # Let the documents be persisted

        # Unguard the structure and check that nothing happens
        del (structure[&#34;guard&#34;])
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))
        structure[&#34;guard&#34;] = False
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))
        structure[&#34;guard&#34;] = True

        # Inject some fake usage data for the structure
        # User cpu is LOWER than the upper limit -&gt; nothing happens
        base_cpu_doc = {&#34;timestamp&#34;: 0, &#34;metric&#34;: &#34;proc.cpu.user&#34;, &#34;value&#34;: 0, &#34;tags&#34;: {&#34;host&#34;: testing_node_name}}
        time_seconds_ago = time.time() - (
                guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;])
        fake_docs = list()
        usage = limits[&#34;resources&#34;][&#34;cpu&#34;][&#34;lower&#34;]
        for i in range(guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;]):
            doc = dict(base_cpu_doc)
            doc[&#34;timestamp&#34;] = time_seconds_ago + i
            doc[&#34;value&#34;] = usage + i
            fake_docs.append(doc)
        success, error = self.opentsdb.send_json_documents(fake_docs)
        self.assertTrue(success)

        time.sleep(2)  # Let the time series database persist the new metrics

        # CPU usage is normal so nothing should happen
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))

        # Move the guardian back in time
        guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] += 50
        self.couchdb.update_service(guardian_service)

        # User cpu is HIGHER than the upper limit -&gt; 1 cpu bottleneck event should be generated
        base_cpu_doc = {&#34;timestamp&#34;: 0, &#34;metric&#34;: &#34;proc.cpu.user&#34;, &#34;value&#34;: 0, &#34;tags&#34;: {&#34;host&#34;: testing_node_name}}
        time_seconds_ago = time.time() - (
                guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;]) - 5
        fake_docs = list()
        usage = limits[&#34;resources&#34;][&#34;cpu&#34;][&#34;upper&#34;]
        for i in range(guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + 5):
            doc = dict(base_cpu_doc)
            doc[&#34;timestamp&#34;] = time_seconds_ago + i
            doc[&#34;value&#34;] = usage + i
            fake_docs.append(doc)
        success, error = self.opentsdb.send_json_documents(fake_docs)
        self.assertTrue(success)
        time.sleep(2)  # Let the time series database persist the new metrics
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        time.sleep(1)  # Let the documents be persisted
        events = self.couchdb.get_events(structure)
        TestCase.assertEqual(self, first=1, second=len(events))
        TestCase.assertEqual(self, first=&#34;CpuBottleneck&#34;, second=events[0][&#34;name&#34;])
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))
        self.couchdb.delete_num_events_by_structure(structure, &#34;CpuBottleneck&#34;, 1)

        # Move the guardian back in time
        guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] += 200
        self.couchdb.update_service(guardian_service)

        # Simulate the generation of a request for cpu and memory by making the guardian go through all the time windows
        num_needed_events = CpuRescaleUp[&#34;rule&#34;][&#34;and&#34;][0][&#34;&gt;=&#34;][1]
        for i in range(num_needed_events):
            fake_docs = list()
            usage = limits[&#34;resources&#34;][&#34;cpu&#34;][&#34;upper&#34;]
            time_seconds_ago = time.time() - (
                    guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;])
            for j in range(guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;]):
                doc = dict(base_cpu_doc)
                doc[&#34;timestamp&#34;] = time_seconds_ago + j
                doc[&#34;value&#34;] = usage + j
                fake_docs.append(doc)
            success, error = self.opentsdb.send_json_documents(fake_docs)
            self.assertTrue(success)
            time.sleep(1)  # Let the time series database persist the new metrics
            self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure,
                                     self.couchdb.get_rules())
            # time.sleep(1)  # Let the documents be persisted
            if i + 1 &lt; num_needed_events:
                events = self.couchdb.get_events(structure)
                TestCase.assertEqual(self, first=i + 1, second=len(events))

            # Move the guardian forward in time
            guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] -= guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;]
            self.couchdb.update_service(guardian_service)

        # The majority of events should have been removed when the request was generated
        events = self.couchdb.get_events(structure)
        # TestCase.assertTrue(self, len(events) &lt; num_needed_events)
        TestCase.assertEqual(self, first=0, second=len(events))

        # 1 requests should have been generated
        requests = self.couchdb.get_requests(structure)
        TestCase.assertEqual(self, first=1, second=len(requests))
        TestCase.assertEqual(self, first=&#34;CpuRescaleUp&#34;, second=requests[0][&#34;action&#34;])


if __name__ == &#39;__main__&#39;:
    unittest.main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.Guardian.testGuardian.GuardianServelerssIntegrationTest"><code class="flex name class">
<span>class <span class="ident">GuardianServelerssIntegrationTest</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GuardianServelerssIntegrationTest(TestCase):

    def tearDown(self):
        self.couchdb.remove_database(&#34;services-test&#34;)
        self.couchdb.remove_database(&#34;structures-test&#34;)
        self.couchdb.remove_database(&#34;limits-test&#34;)
        self.couchdb.remove_database(&#34;rules-test&#34;)
        self.couchdb.remove_database(&#34;events-test&#34;)
        self.couchdb.remove_database(&#34;requests-test&#34;)
        self.couchdb.close_connection()
        self.opentsdb.close_connection()

    def setUp(self):
        def initialize_database(database_type, database_name):
            self.couchdb.set_database_name(database_type, database_name)
            if self.couchdb.database_exists(database_name):
                self.couchdb.remove_database(database_name)
            self.couchdb.create_database(database_name)

        self.couchdb = CouchDBServer(&#34;localhost&#34;, &#34;5984&#34;)
        self.opentsdb = OpenTSDBServer(&#34;localhost&#34;, &#34;4242&#34;)

        initialize_database(&#34;services&#34;, &#34;services-test&#34;)
        initialize_database(&#34;structures&#34;, &#34;structures-test&#34;)
        initialize_database(&#34;limits&#34;, &#34;limits-test&#34;)
        initialize_database(&#34;rules&#34;, &#34;rules-test&#34;)
        initialize_database(&#34;events&#34;, &#34;events-test&#34;)
        initialize_database(&#34;requests&#34;, &#34;requests-test&#34;)

        self.guardian = Guardian.Guardian()
        self.guardian.debug = False

        self.guardian.couchdb_handler = self.couchdb
        self.guardian.opentsdb_handler = self.opentsdb

    def test_serverless(self):
        guardian_service = guardian
        testing_node_name = &#34;testingNode{0}&#34;.format(str(random.randint(0, 10)))
        structure = {&#34;guard&#34;: True, &#34;guard_policy&#34;: &#34;serverless&#34;, &#34;host&#34;: &#34;c14-13&#34;, &#34;host_rescaler_ip&#34;: &#34;c14-13&#34;,
                     &#34;host_rescaler_port&#34;: &#34;8000&#34;,
                     &#34;resources&#34;: {
                         &#34;cpu&#34;: {
                             &#34;current&#34;: 140,
                             &#34;guard&#34;: True,
                             &#34;max&#34;: 200,
                             &#34;min&#34;: 50
                         },
                         &#34;energy&#34;: {
                             &#34;guard&#34;: True,
                             &#34;max&#34;: 20,
                             &#34;min&#34;: 0,
                             &#34;usage&#34;: 2.34
                         },
                         &#34;mem&#34;: {
                             &#34;current&#34;: 3072,
                             &#34;guard&#34;: True,
                             &#34;max&#34;: 10240,
                             &#34;min&#34;: 512
                         }
                     }, &#34;subtype&#34;: &#34;container&#34;, &#34;type&#34;: &#34;structure&#34;, &#34;name&#34;: testing_node_name}

        limits = {&#34;type&#34;: &#34;limit&#34;, &#34;resources&#34;: {&#34;cpu&#34;: {&#34;upper&#34;: 120, &#34;lower&#34;: 80, &#34;boundary&#34;: 20},
                                                 &#34;mem&#34;: {&#34;upper&#34;: 2048, &#34;lower&#34;: 1024, &#34;boundary&#34;: 1024},
                                                 &#34;energy&#34;: {&#34;upper&#34;: 20, &#34;lower&#34;: 10, &#34;boundary&#34;: 10}
                                                 }, &#34;name&#34;: testing_node_name}

        event_rules = [cpu_exceeded_upper, cpu_dropped_lower, mem_exceeded_upper, mem_dropped_lower]
        rescaling_rules = [CpuRescaleUp, CpuRescaleDown, MemRescaleUp, MemRescaleDown]
        for rule in event_rules + rescaling_rules:
            rule[&#34;active&#34;] = True

        guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] = 20
        guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] = 100 + random.randint(0, 100)
        guardian_service[&#34;config&#34;][&#34;EVENT_TIMEOUT&#34;] = 100

        # Add the guardian service, a structure
        self.couchdb.add_service(guardian_service)
        guardian_service = self.couchdb.get_service(&#34;guardian&#34;)
        self.couchdb.add_structure(structure)

        # Check that without usage data, nothing is donde
        structure[&#34;guard&#34;] = True
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))

        # Check that without limits, nothing is done
        structure[&#34;guard&#34;] = True
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))

        # Add the limits and rules
        self.couchdb.add_limit(limits)
        for rule in event_rules + rescaling_rules:
            self.couchdb.add_rule(rule)

        time.sleep(2)  # Let the documents be persisted

        # Unguard the structure and check that nothing happens
        del (structure[&#34;guard&#34;])
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))
        structure[&#34;guard&#34;] = False
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))
        structure[&#34;guard&#34;] = True

        # Inject some fake usage data for the structure
        # User cpu is LOWER than the upper limit -&gt; nothing happens
        base_cpu_doc = {&#34;timestamp&#34;: 0, &#34;metric&#34;: &#34;proc.cpu.user&#34;, &#34;value&#34;: 0, &#34;tags&#34;: {&#34;host&#34;: testing_node_name}}
        time_seconds_ago = time.time() - (
                guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;])
        fake_docs = list()
        usage = limits[&#34;resources&#34;][&#34;cpu&#34;][&#34;lower&#34;]
        for i in range(guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;]):
            doc = dict(base_cpu_doc)
            doc[&#34;timestamp&#34;] = time_seconds_ago + i
            doc[&#34;value&#34;] = usage + i
            fake_docs.append(doc)
        success, error = self.opentsdb.send_json_documents(fake_docs)
        self.assertTrue(success)

        time.sleep(2)  # Let the time series database persist the new metrics

        # CPU usage is normal so nothing should happen
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))

        # Move the guardian back in time
        guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] += 50
        self.couchdb.update_service(guardian_service)

        # User cpu is HIGHER than the upper limit -&gt; 1 cpu bottleneck event should be generated
        base_cpu_doc = {&#34;timestamp&#34;: 0, &#34;metric&#34;: &#34;proc.cpu.user&#34;, &#34;value&#34;: 0, &#34;tags&#34;: {&#34;host&#34;: testing_node_name}}
        time_seconds_ago = time.time() - (
                guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;]) - 5
        fake_docs = list()
        usage = limits[&#34;resources&#34;][&#34;cpu&#34;][&#34;upper&#34;]
        for i in range(guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + 5):
            doc = dict(base_cpu_doc)
            doc[&#34;timestamp&#34;] = time_seconds_ago + i
            doc[&#34;value&#34;] = usage + i
            fake_docs.append(doc)
        success, error = self.opentsdb.send_json_documents(fake_docs)
        self.assertTrue(success)
        time.sleep(2)  # Let the time series database persist the new metrics
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
        time.sleep(1)  # Let the documents be persisted
        events = self.couchdb.get_events(structure)
        TestCase.assertEqual(self, first=1, second=len(events))
        TestCase.assertEqual(self, first=&#34;CpuBottleneck&#34;, second=events[0][&#34;name&#34;])
        TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))
        self.couchdb.delete_num_events_by_structure(structure, &#34;CpuBottleneck&#34;, 1)

        # Move the guardian back in time
        guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] += 200
        self.couchdb.update_service(guardian_service)

        # Simulate the generation of a request for cpu and memory by making the guardian go through all the time windows
        num_needed_events = CpuRescaleUp[&#34;rule&#34;][&#34;and&#34;][0][&#34;&gt;=&#34;][1]
        for i in range(num_needed_events):
            fake_docs = list()
            usage = limits[&#34;resources&#34;][&#34;cpu&#34;][&#34;upper&#34;]
            time_seconds_ago = time.time() - (
                    guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;])
            for j in range(guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;]):
                doc = dict(base_cpu_doc)
                doc[&#34;timestamp&#34;] = time_seconds_ago + j
                doc[&#34;value&#34;] = usage + j
                fake_docs.append(doc)
            success, error = self.opentsdb.send_json_documents(fake_docs)
            self.assertTrue(success)
            time.sleep(1)  # Let the time series database persist the new metrics
            self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure,
                                     self.couchdb.get_rules())
            # time.sleep(1)  # Let the documents be persisted
            if i + 1 &lt; num_needed_events:
                events = self.couchdb.get_events(structure)
                TestCase.assertEqual(self, first=i + 1, second=len(events))

            # Move the guardian forward in time
            guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] -= guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;]
            self.couchdb.update_service(guardian_service)

        # The majority of events should have been removed when the request was generated
        events = self.couchdb.get_events(structure)
        # TestCase.assertTrue(self, len(events) &lt; num_needed_events)
        TestCase.assertEqual(self, first=0, second=len(events))

        # 1 requests should have been generated
        requests = self.couchdb.get_requests(structure)
        TestCase.assertEqual(self, first=1, second=len(requests))
        TestCase.assertEqual(self, first=&#34;CpuRescaleUp&#34;, second=requests[0][&#34;action&#34;])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.Guardian.testGuardian.GuardianServelerssIntegrationTest.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
    def initialize_database(database_type, database_name):
        self.couchdb.set_database_name(database_type, database_name)
        if self.couchdb.database_exists(database_name):
            self.couchdb.remove_database(database_name)
        self.couchdb.create_database(database_name)

    self.couchdb = CouchDBServer(&#34;localhost&#34;, &#34;5984&#34;)
    self.opentsdb = OpenTSDBServer(&#34;localhost&#34;, &#34;4242&#34;)

    initialize_database(&#34;services&#34;, &#34;services-test&#34;)
    initialize_database(&#34;structures&#34;, &#34;structures-test&#34;)
    initialize_database(&#34;limits&#34;, &#34;limits-test&#34;)
    initialize_database(&#34;rules&#34;, &#34;rules-test&#34;)
    initialize_database(&#34;events&#34;, &#34;events-test&#34;)
    initialize_database(&#34;requests&#34;, &#34;requests-test&#34;)

    self.guardian = Guardian.Guardian()
    self.guardian.debug = False

    self.guardian.couchdb_handler = self.couchdb
    self.guardian.opentsdb_handler = self.opentsdb</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianServelerssIntegrationTest.tearDown"><code class="name flex">
<span>def <span class="ident">tearDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Hook method for deconstructing the test fixture after testing it.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tearDown(self):
    self.couchdb.remove_database(&#34;services-test&#34;)
    self.couchdb.remove_database(&#34;structures-test&#34;)
    self.couchdb.remove_database(&#34;limits-test&#34;)
    self.couchdb.remove_database(&#34;rules-test&#34;)
    self.couchdb.remove_database(&#34;events-test&#34;)
    self.couchdb.remove_database(&#34;requests-test&#34;)
    self.couchdb.close_connection()
    self.opentsdb.close_connection()</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianServelerssIntegrationTest.test_serverless"><code class="name flex">
<span>def <span class="ident">test_serverless</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_serverless(self):
    guardian_service = guardian
    testing_node_name = &#34;testingNode{0}&#34;.format(str(random.randint(0, 10)))
    structure = {&#34;guard&#34;: True, &#34;guard_policy&#34;: &#34;serverless&#34;, &#34;host&#34;: &#34;c14-13&#34;, &#34;host_rescaler_ip&#34;: &#34;c14-13&#34;,
                 &#34;host_rescaler_port&#34;: &#34;8000&#34;,
                 &#34;resources&#34;: {
                     &#34;cpu&#34;: {
                         &#34;current&#34;: 140,
                         &#34;guard&#34;: True,
                         &#34;max&#34;: 200,
                         &#34;min&#34;: 50
                     },
                     &#34;energy&#34;: {
                         &#34;guard&#34;: True,
                         &#34;max&#34;: 20,
                         &#34;min&#34;: 0,
                         &#34;usage&#34;: 2.34
                     },
                     &#34;mem&#34;: {
                         &#34;current&#34;: 3072,
                         &#34;guard&#34;: True,
                         &#34;max&#34;: 10240,
                         &#34;min&#34;: 512
                     }
                 }, &#34;subtype&#34;: &#34;container&#34;, &#34;type&#34;: &#34;structure&#34;, &#34;name&#34;: testing_node_name}

    limits = {&#34;type&#34;: &#34;limit&#34;, &#34;resources&#34;: {&#34;cpu&#34;: {&#34;upper&#34;: 120, &#34;lower&#34;: 80, &#34;boundary&#34;: 20},
                                             &#34;mem&#34;: {&#34;upper&#34;: 2048, &#34;lower&#34;: 1024, &#34;boundary&#34;: 1024},
                                             &#34;energy&#34;: {&#34;upper&#34;: 20, &#34;lower&#34;: 10, &#34;boundary&#34;: 10}
                                             }, &#34;name&#34;: testing_node_name}

    event_rules = [cpu_exceeded_upper, cpu_dropped_lower, mem_exceeded_upper, mem_dropped_lower]
    rescaling_rules = [CpuRescaleUp, CpuRescaleDown, MemRescaleUp, MemRescaleDown]
    for rule in event_rules + rescaling_rules:
        rule[&#34;active&#34;] = True

    guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] = 20
    guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] = 100 + random.randint(0, 100)
    guardian_service[&#34;config&#34;][&#34;EVENT_TIMEOUT&#34;] = 100

    # Add the guardian service, a structure
    self.couchdb.add_service(guardian_service)
    guardian_service = self.couchdb.get_service(&#34;guardian&#34;)
    self.couchdb.add_structure(structure)

    # Check that without usage data, nothing is donde
    structure[&#34;guard&#34;] = True
    self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
    TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
    TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))

    # Check that without limits, nothing is done
    structure[&#34;guard&#34;] = True
    self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
    TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
    TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))

    # Add the limits and rules
    self.couchdb.add_limit(limits)
    for rule in event_rules + rescaling_rules:
        self.couchdb.add_rule(rule)

    time.sleep(2)  # Let the documents be persisted

    # Unguard the structure and check that nothing happens
    del (structure[&#34;guard&#34;])
    self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
    TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
    TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))
    structure[&#34;guard&#34;] = False
    self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
    TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
    TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))
    structure[&#34;guard&#34;] = True

    # Inject some fake usage data for the structure
    # User cpu is LOWER than the upper limit -&gt; nothing happens
    base_cpu_doc = {&#34;timestamp&#34;: 0, &#34;metric&#34;: &#34;proc.cpu.user&#34;, &#34;value&#34;: 0, &#34;tags&#34;: {&#34;host&#34;: testing_node_name}}
    time_seconds_ago = time.time() - (
            guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;])
    fake_docs = list()
    usage = limits[&#34;resources&#34;][&#34;cpu&#34;][&#34;lower&#34;]
    for i in range(guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;]):
        doc = dict(base_cpu_doc)
        doc[&#34;timestamp&#34;] = time_seconds_ago + i
        doc[&#34;value&#34;] = usage + i
        fake_docs.append(doc)
    success, error = self.opentsdb.send_json_documents(fake_docs)
    self.assertTrue(success)

    time.sleep(2)  # Let the time series database persist the new metrics

    # CPU usage is normal so nothing should happen
    self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
    TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_events(structure)))
    TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))

    # Move the guardian back in time
    guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] += 50
    self.couchdb.update_service(guardian_service)

    # User cpu is HIGHER than the upper limit -&gt; 1 cpu bottleneck event should be generated
    base_cpu_doc = {&#34;timestamp&#34;: 0, &#34;metric&#34;: &#34;proc.cpu.user&#34;, &#34;value&#34;: 0, &#34;tags&#34;: {&#34;host&#34;: testing_node_name}}
    time_seconds_ago = time.time() - (
            guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;]) - 5
    fake_docs = list()
    usage = limits[&#34;resources&#34;][&#34;cpu&#34;][&#34;upper&#34;]
    for i in range(guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + 5):
        doc = dict(base_cpu_doc)
        doc[&#34;timestamp&#34;] = time_seconds_ago + i
        doc[&#34;value&#34;] = usage + i
        fake_docs.append(doc)
    success, error = self.opentsdb.send_json_documents(fake_docs)
    self.assertTrue(success)
    time.sleep(2)  # Let the time series database persist the new metrics
    self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure, self.couchdb.get_rules())
    time.sleep(1)  # Let the documents be persisted
    events = self.couchdb.get_events(structure)
    TestCase.assertEqual(self, first=1, second=len(events))
    TestCase.assertEqual(self, first=&#34;CpuBottleneck&#34;, second=events[0][&#34;name&#34;])
    TestCase.assertEqual(self, first=0, second=len(self.couchdb.get_requests(structure)))
    self.couchdb.delete_num_events_by_structure(structure, &#34;CpuBottleneck&#34;, 1)

    # Move the guardian back in time
    guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] += 200
    self.couchdb.update_service(guardian_service)

    # Simulate the generation of a request for cpu and memory by making the guardian go through all the time windows
    num_needed_events = CpuRescaleUp[&#34;rule&#34;][&#34;and&#34;][0][&#34;&gt;=&#34;][1]
    for i in range(num_needed_events):
        fake_docs = list()
        usage = limits[&#34;resources&#34;][&#34;cpu&#34;][&#34;upper&#34;]
        time_seconds_ago = time.time() - (
                guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;] + guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;])
        for j in range(guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;]):
            doc = dict(base_cpu_doc)
            doc[&#34;timestamp&#34;] = time_seconds_ago + j
            doc[&#34;value&#34;] = usage + j
            fake_docs.append(doc)
        success, error = self.opentsdb.send_json_documents(fake_docs)
        self.assertTrue(success)
        time.sleep(1)  # Let the time series database persist the new metrics
        self.guardian.serverless(self.couchdb.get_service(&#34;guardian&#34;)[&#34;config&#34;], structure,
                                 self.couchdb.get_rules())
        # time.sleep(1)  # Let the documents be persisted
        if i + 1 &lt; num_needed_events:
            events = self.couchdb.get_events(structure)
            TestCase.assertEqual(self, first=i + 1, second=len(events))

        # Move the guardian forward in time
        guardian_service[&#34;config&#34;][&#34;WINDOW_DELAY&#34;] -= guardian_service[&#34;config&#34;][&#34;WINDOW_TIMELAPSE&#34;]
        self.couchdb.update_service(guardian_service)

    # The majority of events should have been removed when the request was generated
    events = self.couchdb.get_events(structure)
    # TestCase.assertTrue(self, len(events) &lt; num_needed_events)
    TestCase.assertEqual(self, first=0, second=len(events))

    # 1 requests should have been generated
    requests = self.couchdb.get_requests(structure)
    TestCase.assertEqual(self, first=1, second=len(requests))
    TestCase.assertEqual(self, first=&#34;CpuRescaleUp&#34;, second=requests[0][&#34;action&#34;])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest"><code class="flex name class">
<span>class <span class="ident">GuardianTest</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<section class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GuardianTest(TestCase):
    def setUp(self):
        self.guardian = Guardian.Guardian()

    def test_check_invalid_values(self):

        # An error should be thrown
        with self.assertRaises(ValueError):
            self.guardian.check_invalid_values(20, &#34;label1&#34;, 10, &#34;label2&#34;)

        # Nothing should happen
        TestCase.assertEqual(self, first=None, second=self.guardian.check_invalid_values(10, &#34;label1&#34;, 20, &#34;label2&#34;))

    def test_check_unset_values(self):
        # An error should be thrown
        with self.assertRaises(ValueError):
            self.guardian.check_unset_values(NOT_AVAILABLE_STRING, &#34;min&#34;, &#34;cpu&#34;)

            # Nothing should happen
            self.guardian.check_unset_values(1, &#34;min&#34;, &#34;cpu&#34;)

    def test_try_get_value(self):
        TestCase.assertEqual(self, first=1, second=self.guardian.try_get_value({&#34;KEY&#34;: 1}, &#34;KEY&#34;))
        TestCase.assertEqual(self, first=NOT_AVAILABLE_STRING,
                             second=self.guardian.try_get_value({&#34;KEY&#34;: 1}, &#34;NOKEY&#34;))

    def test_generate_event_name(self):
        scale_down = {&#34;scale&#34;: {&#34;down&#34;: 5}}
        scale_up = {&#34;scale&#34;: {&#34;up&#34;: 2}}

        TestCase.assertEqual(self, first=&#34;CpuUnderuse&#34;, second=generate_event_name(scale_down, &#34;cpu&#34;))
        TestCase.assertEqual(self, first=&#34;MemUnderuse&#34;, second=generate_event_name(scale_down, &#34;mem&#34;))
        TestCase.assertEqual(self, first=&#34;DiskUnderuse&#34;, second=generate_event_name(scale_down, &#34;disk&#34;))
        TestCase.assertEqual(self, first=&#34;NetUnderuse&#34;, second=generate_event_name(scale_down, &#34;net&#34;))

        TestCase.assertEqual(self, first=&#34;CpuBottleneck&#34;, second=generate_event_name(scale_up, &#34;cpu&#34;))
        TestCase.assertEqual(self, first=&#34;MemBottleneck&#34;, second=generate_event_name(scale_up, &#34;mem&#34;))
        TestCase.assertEqual(self, first=&#34;DiskBottleneck&#34;, second=generate_event_name(scale_up, &#34;disk&#34;))
        TestCase.assertEqual(self, first=&#34;NetBottleneck&#34;, second=generate_event_name(scale_up, &#34;net&#34;))

        scale_invalid1 = {&#34;bogus&#34;: 1}
        scale_invalid2 = {&#34;scale&#34;: {&#34;bogus&#34;: 1}}

        with self.assertRaises(ValueError):
            generate_event_name(scale_invalid1, &#34;cpu&#34;)

        with self.assertRaises(ValueError):
            generate_event_name(scale_invalid2, &#34;cpu&#34;)

    def test_filter_old_events(self):
        all_events = list()
        timeout = 20

        for i in range(0, 5):
            now = time.time()
            ago = now - timeout - 4
            all_events.append({&#34;timestamp&#34;: now})
            all_events.append({&#34;timestamp&#34;: ago})

        valid, invalid = self.guardian.sort_events(all_events, timeout)

        TestCase.assertEqual(self, first=5, second=len(invalid))
        TestCase.assertEqual(self, first=5, second=len(valid))

    def test_reduce_structure_events(self):
        input_events = list()
        for i in range(1, 5):
            input_events.append({&#34;resource&#34;: &#34;cpu&#34;, &#34;action&#34;: {&#34;events&#34;: {&#34;scale&#34;: {&#34;up&#34;: i, &#34;down&#34;: 0}}}})

        for i in range(2, 6):
            input_events.append({&#34;resource&#34;: &#34;cpu&#34;, &#34;action&#34;: {&#34;events&#34;: {&#34;scale&#34;: {&#34;up&#34;: 0, &#34;down&#34;: i}}}})

        expected_output = {&#34;cpu&#34;: {&#34;events&#34;: {&#34;scale&#34;: {&#34;up&#34;: sum(range(1, 5)), &#34;down&#34;: sum(range(2, 6))}}}}

        TestCase.assertEqual(self, first=expected_output, second=self.guardian.reduce_structure_events(input_events))

    def test_correct_container_state(self):
        def get_valid_state():
            resources_dict = dict(
                cpu=dict(max=300, current=170, min=50),
                mem=dict(max=8192, current=4096, min=256)
            )

            limits_dict = dict(
                cpu=dict(upper=140, lower=110, boundary=30),
                mem=dict(upper=3072, lower=2048, boundary=1024)

            )
            return resources_dict, limits_dict

        # State should be valid
        resources, limits = get_valid_state()
        TestCase.assertEqual(self, first=limits,
                             second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

        # Make resources and limits invalid because invalid boundary
        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            resources, limits = get_valid_state()
            # Upper too close to current
            limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - int(limits[resource][&#34;boundary&#34;] / 2)
            TestCase.assertEqual(self, first=limits,
                                 second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

            # Upper too far away to current
            limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - limits[resource][&#34;boundary&#34;] * 2
            TestCase.assertEqual(self, first=limits,
                                 second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

            # Lower too close to upper
            limits[resource][&#34;lower&#34;] = limits[resource][&#34;upper&#34;] - int(limits[resource][&#34;boundary&#34;] / 2)
            TestCase.assertEqual(self, first=limits,
                                 second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

            # Lower too far away to upper
            limits[resource][&#34;lower&#34;] = limits[resource][&#34;upper&#34;] - limits[resource][&#34;boundary&#34;] * 2
            TestCase.assertEqual(self, first=limits,
                                 second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

    def test_invalid_container_state(self):
        def get_valid_state():
            resources_dict = dict(
                cpu=dict(max=300, current=170, min=50),
                mem=dict(max=8192, current=4096, min=256)
            )

            limits_dict = dict(
                cpu=dict(upper=140, lower=110, boundary=30),
                mem=dict(upper=3072, lower=2048, boundary=1024)

            )
            return resources_dict, limits_dict

        # State should be valid
        resources, limits = get_valid_state()
        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            self.assertFalse(self.guardian.check_invalid_container_state(resources, limits, resource))

        # Make resources and limits invalid because unset
        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            for key in [(&#34;max&#34;, &#34;resource&#34;), (&#34;min&#34;, &#34;resource&#34;), (&#34;upper&#34;, &#34;limit&#34;), (&#34;lower&#34;, &#34;limit&#34;)]:
                label, doc_type = key
                resources, limits = get_valid_state()
                if doc_type == &#34;limit&#34;:
                    limits[resource][label] = NOT_AVAILABLE_STRING
                if doc_type == &#34;resource&#34;:
                    resources[resource][label] = NOT_AVAILABLE_STRING
                with self.assertRaises(ValueError):
                    self.guardian.check_invalid_container_state(resources, limits, resource)

        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            # Invalid because max &lt; current
            resources, limits = get_valid_state()
            resources[resource][&#34;max&#34;], resources[resource][&#34;current&#34;] = \
                resources[resource][&#34;current&#34;], resources[resource][&#34;max&#34;]
            with self.assertRaises(ValueError):
                self.guardian.check_invalid_container_state(resources, limits, resource)

            # Invalid because current &lt; upper
            resources, limits = get_valid_state()
            resources[resource][&#34;current&#34;], limits[resource][&#34;upper&#34;] = \
                limits[resource][&#34;upper&#34;], resources[resource][&#34;current&#34;]
            with self.assertRaises(ValueError):
                self.guardian.check_invalid_container_state(resources, limits, resource)

            # Invalid because upper &lt; lower
            resources, limits = get_valid_state()
            limits[resource][&#34;upper&#34;], limits[resource][&#34;lower&#34;] = limits[resource][&#34;lower&#34;], limits[resource][&#34;upper&#34;]
            with self.assertRaises(ValueError):
                self.guardian.check_invalid_container_state(resources, limits, resource)

            # Invalid because lower &lt; min
            # TODO Test deactivated, see TODO in tested function
            # resources, limits = get_valid_state()
            # resources[resource][&#34;min&#34;], limits[resource][&#34;lower&#34;] = \
            #     limits[resource][&#34;lower&#34;], resources[resource][&#34;min&#34;]
            # with self.assertRaises(ValueError):
            #     self.guardian.check_invalid_container_state(resources, limits, resource)

        # Make resources and limits invalid because invalid boundary
        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            resources, limits = get_valid_state()
            # Upper too close to current
            limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - int(limits[resource][&#34;boundary&#34;] / 2)
            with self.assertRaises(ValueError):
                self.guardian.check_invalid_container_state(resources, limits, resource)
            # Upper too far away to current
            limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - limits[resource][&#34;boundary&#34;] * 2
            with self.assertRaises(ValueError):
                self.guardian.check_invalid_container_state(resources, limits, resource)

            # resources, limits = get_valid_state()
            # # Lower too close to upper
            # limits[resource][&#34;lower&#34;] = limits[resource][&#34;upper&#34;] - limits[resource][&#34;boundary&#34;] / 2
            # with self.assertRaises(ValueError):
            #     guardian.invalid_container_state(resources, limits)
            # # Lower too far away to upper
            # limits[resource][&#34;lower&#34;] = limits[resource][&#34;upper&#34;] - limits[resource][&#34;boundary&#34;] * 2
            # with self.assertRaises(ValueError):
            #     guardian.invalid_container_state(resources, limits)

    def test_get_container_resources_str(self):

        resources_dict = dict(
            cpu=dict(max=300, current=200, min=50),
            mem=dict(max=8192, current=2048, min=256),
            disk=dict(max=200, current=80, min=50),
            net=dict(max=200, current=80, min=50)
        )

        limits_dict = dict(
            cpu=dict(upper=140, lower=70, boundary=70),
            mem=dict(upper=8000, lower=7000, boundary=1000),
            disk=dict(upper=70, lower=60),
            net=dict(upper=70, lower=60)
        )

        usages_dict = {
            &#34;structure.cpu.usage&#34;: 22.5664364,
            &#34;structure.mem.usage&#34;: 2341.9734,
        }

        TestCase.assertEqual(self, first=&#34;300,200,140,22.57,70,50&#34;,
                             second=self.guardian.get_resource_summary(&#34;cpu&#34;, resources_dict, limits_dict,
                                                                       usages_dict))
        TestCase.assertEqual(self, first=&#34;8192,2048,8000,2341.97,7000,256&#34;,
                             second=self.guardian.get_resource_summary(&#34;mem&#34;, resources_dict, limits_dict,
                                                                       usages_dict))

    def test_container_energy_str(self):
        resources_dict = dict(
            energy=dict(max=50, usage=20, min=0)
        )

        TestCase.assertEqual(self, first=&#34;50,20,0&#34;, second=self.guardian.get_container_energy_str(resources_dict))

    def test_adjust_if_invalid_amount(self):
        structure_resources = {&#34;max&#34;: 400, &#34;min&#34;: 50, &#34;current&#34;: 200}
        structure_limits = {&#34;upper&#34;: 150, &#34;lower&#34;: 100}

        # Correct cases
        TestCase.assertEqual(self, first=70,
                             second=self.guardian.adjust_amount(70, structure_resources, structure_limits))
        TestCase.assertEqual(self, first=100,
                             second=self.guardian.adjust_amount(100, structure_resources, structure_limits))

        # Over the max
        TestCase.assertEqual(self, first=200,
                             second=self.guardian.adjust_amount(250, structure_resources, structure_limits))
        TestCase.assertEqual(self, first=200,
                             second=self.guardian.adjust_amount(260, structure_resources, structure_limits))

        # Correct cases
        TestCase.assertEqual(self, first=-10,
                             second=self.guardian.adjust_amount(-10, structure_resources, structure_limits))
        TestCase.assertEqual(self, first=-50,
                             second=self.guardian.adjust_amount(-50, structure_resources, structure_limits))

        # Under the minimum
        TestCase.assertEqual(self, first=-50,
                             second=self.guardian.adjust_amount(-60, structure_resources, structure_limits))
        TestCase.assertEqual(self, first=-50,
                             second=self.guardian.adjust_amount(-100, structure_resources, structure_limits))

        structure_resources = {&#34;max&#34;: 40, &#34;min&#34;: 5, &#34;current&#34;: 20}
        structure_limits = {&#34;upper&#34;: 15, &#34;lower&#34;: 10}
        TestCase.assertEqual(self, first=10,
                             second=self.guardian.adjust_amount(10, structure_resources, structure_limits))

    def test_get_amount_from_percentage_reduction(self):
        resource = &#34;mem&#34;
        structure = {&#34;resources&#34;: {&#34;mem&#34;: {&#34;max&#34;: 4096, &#34;min&#34;: 280, &#34;current&#34;: 2000}}}
        usages = {&#34;structure.mem.usage&#34;: 700}

        TestCase.assertEqual(self, first=-260,
                             second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 20))
        TestCase.assertEqual(self, first=-520,
                             second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 40))

        TestCase.assertEqual(self, first=-650,
                             second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 50))

        # Should max out at 50%
        TestCase.assertEqual(self, first=-650,
                             second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 70))

    def test_get_amount_from_proportional_energy_rescaling(self):
        resource = &#34;energy&#34;

        def check():
            data = structure[&#34;resources&#34;][&#34;energy&#34;]
            expected = (data[&#34;max&#34;] - data[&#34;usage&#34;]) * CPU_SHARES_PER_WATT
            TestCase.assertEqual(self, first=expected,
                                 second=self.guardian.get_amount_from_proportional_energy_rescaling(structure,
                                                                                                    resource))

        structure = {&#34;resources&#34;: {&#34;energy&#34;: {&#34;max&#34;: 60, &#34;min&#34;: 10, &#34;usage&#34;: 30}}}
        check()
        structure = {&#34;resources&#34;: {&#34;energy&#34;: {&#34;max&#34;: 60, &#34;min&#34;: 10, &#34;usage&#34;: 80}}}
        check()

    def test_get_amount_from_fit_reduction(self):
        current_resource_limit = 2000
        current_resource_usage = 700
        boundary = 500

        # To properly fit the limit, the usage (700) has to be placed between the upper and lower limit,
        # keeping the inter-limit boundary (500) so the new limits should be (950,450)
        # finally, keeping the real resource limit to the upper limit boundary (500), the final
        # current value to apply should be (upper limit)950 + 500(boundary) = 1450
        # so the amount to reduce is 2000 - 1450 = 550
        TestCase.assertEqual(self,
                             first=self.guardian.get_amount_from_fit_reduction(current_resource_limit, boundary,
                                                                               current_resource_usage),
                             second=-550)

    def test_match_usages_and_limits(self):
        def assert_event_equals(rule, ev):
            event_expected_name = generate_event_name(rule[&#34;action&#34;][&#34;events&#34;], rule[&#34;resource&#34;])
            self.assertTrue(event_expected_name, ev[&#34;name&#34;])
            self.assertTrue(structure_name, ev[&#34;structure&#34;])
            self.assertTrue(rule[&#34;action&#34;], ev[&#34;action&#34;])
            self.assertTrue(&#34;event&#34;, ev[&#34;type&#34;])
            self.assertTrue(rule[&#34;resource&#34;], ev[&#34;resource&#34;])

        mem_exceeded_upper[&#34;active&#34;] = True
        mem_dropped_lower[&#34;active&#34;] = True

        rules = [mem_exceeded_upper, mem_dropped_lower]
        structure_name = &#34;node99&#34;

        resources = dict(
            mem=dict(max=8192, current=4096, min=256, guard=True),
        )

        limits = dict(
            mem=dict(upper=2048, lower=1024),
        )
        usages = {&#34;structure.mem.usage&#34;: 1536}

        # No events expected
        TestCase.assertEqual(self, [],
                             second=self.guardian.match_usages_and_limits(structure_name, rules, usages, limits,
                                                                          resources))

        # Expect mem underuse event
        usages[&#34;structure.mem.usage&#34;] = limits[&#34;mem&#34;][&#34;lower&#34;] - 100
        events = self.guardian.match_usages_and_limits(structure_name, rules, usages, limits, resources)
        if not events:
            self.fail(&#34;No events were triggered when expected.&#34;)
        else:
            event = events[0]
            assert_event_equals(mem_dropped_lower, event)

        # Expect mem bottleneck event
        usages[&#34;structure.mem.usage&#34;] = limits[&#34;mem&#34;][&#34;upper&#34;] + 100
        events = self.guardian.match_usages_and_limits(structure_name, rules, usages, limits, resources)
        if not events:
            self.fail(&#34;No events were triggered when expected.&#34;)
        else:
            event = events[0]
            assert_event_equals(mem_dropped_lower, event)

    def test_match_rules_and_events(self):

        def get_valid_state():
            st = {
                &#34;guard&#34;: True,
                &#34;guard_policy&#34;: &#34;serverless&#34;,
                &#34;host&#34;: &#34;c14-13&#34;,
                &#34;host_rescaler_ip&#34;: &#34;c14-13&#34;,
                &#34;host_rescaler_port&#34;: &#34;8000&#34;,
                &#34;name&#34;: &#34;node0&#34;,
                &#34;resources&#34;: {
                    &#34;cpu&#34;: {
                        &#34;current&#34;: 140,
                        &#34;guard&#34;: True,
                        &#34;max&#34;: 200,
                        &#34;min&#34;: 50
                    },
                    &#34;energy&#34;: {
                        &#34;guard&#34;: False,
                        &#34;max&#34;: 20,
                        &#34;min&#34;: 0,
                        &#34;usage&#34;: 2.34
                    },
                    &#34;mem&#34;: {
                        &#34;current&#34;: 3072,
                        &#34;guard&#34;: True,
                        &#34;max&#34;: 10240,
                        &#34;min&#34;: 512
                    }
                },
                &#34;subtype&#34;: &#34;container&#34;,
                &#34;type&#34;: &#34;structure&#34;
            }
            lim = {&#34;cpu&#34;: {&#34;upper&#34;: 120, &#34;lower&#34;: 80, &#34;boundary&#34;: 20},
                   &#34;mem&#34;: {&#34;upper&#34;: 2048, &#34;lower&#34;: 1024, &#34;boundary&#34;: 1024},
                   &#34;energy&#34;: {&#34;upper&#34;: 20, &#34;lower&#34;: 10, &#34;boundary&#34;: 5},
                   }

            us = {&#34;structure.cpu.usage&#34;: 100, &#34;structure.mem.usage&#34;: 1536, &#34;structure.energy.usage&#34;: 15}

            return st, lim, us

        event_rules = [cpu_exceeded_upper, cpu_dropped_lower, mem_exceeded_upper, mem_dropped_lower,
                       energy_exceeded_upper, energy_dropped_lower]
        rescaling_rules = [CpuRescaleUp, CpuRescaleDown, MemRescaleUp, MemRescaleDown, EnergyRescaleUp,
                           EnergyRescaleDown]
        for rule in event_rules + rescaling_rules:
            rule[&#34;active&#34;] = True

        for tuple in [(&#34;cpu&#34;, CpuRescaleDown, -50), (&#34;mem&#34;, MemRescaleDown, -50), (&#34;cpu&#34;, CpuRescaleUp, 100),
                      (&#34;mem&#34;, MemRescaleUp, 2034)]:

            resource, rescale_rule, amount = tuple
            structure, limits, usages = get_valid_state()

            usages[&#34;structure.&#34; + resource + &#34;.usage&#34;] = limits[resource][&#34;lower&#34;] + amount
            events = list()

            num_needed_events = rescale_rule[&#34;rule&#34;][&#34;and&#34;][0][&#34;&gt;=&#34;][1]

            for i in range(num_needed_events):
                events += self.guardian.match_usages_and_limits(structure[&#34;name&#34;], event_rules, usages, limits,
                                                                structure[&#34;resources&#34;])
            events = self.guardian.reduce_structure_events(events)

            generated_requests, events_to_remove = self.guardian.match_rules_and_events(structure, rescaling_rules,
                                                                                        events, limits,
                                                                                        usages)

            expected_events_to_remove = dict()
            event_to_remove_name = MyUtils.generate_event_name(events[resource][&#34;events&#34;], resource)
            expected_events_to_remove[event_to_remove_name] = num_needed_events

            TestCase.assertEqual(self, first=expected_events_to_remove, second=events_to_remove)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.Guardian.testGuardian.GuardianTest.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
    self.guardian = Guardian.Guardian()</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_adjust_if_invalid_amount"><code class="name flex">
<span>def <span class="ident">test_adjust_if_invalid_amount</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_adjust_if_invalid_amount(self):
    structure_resources = {&#34;max&#34;: 400, &#34;min&#34;: 50, &#34;current&#34;: 200}
    structure_limits = {&#34;upper&#34;: 150, &#34;lower&#34;: 100}

    # Correct cases
    TestCase.assertEqual(self, first=70,
                         second=self.guardian.adjust_amount(70, structure_resources, structure_limits))
    TestCase.assertEqual(self, first=100,
                         second=self.guardian.adjust_amount(100, structure_resources, structure_limits))

    # Over the max
    TestCase.assertEqual(self, first=200,
                         second=self.guardian.adjust_amount(250, structure_resources, structure_limits))
    TestCase.assertEqual(self, first=200,
                         second=self.guardian.adjust_amount(260, structure_resources, structure_limits))

    # Correct cases
    TestCase.assertEqual(self, first=-10,
                         second=self.guardian.adjust_amount(-10, structure_resources, structure_limits))
    TestCase.assertEqual(self, first=-50,
                         second=self.guardian.adjust_amount(-50, structure_resources, structure_limits))

    # Under the minimum
    TestCase.assertEqual(self, first=-50,
                         second=self.guardian.adjust_amount(-60, structure_resources, structure_limits))
    TestCase.assertEqual(self, first=-50,
                         second=self.guardian.adjust_amount(-100, structure_resources, structure_limits))

    structure_resources = {&#34;max&#34;: 40, &#34;min&#34;: 5, &#34;current&#34;: 20}
    structure_limits = {&#34;upper&#34;: 15, &#34;lower&#34;: 10}
    TestCase.assertEqual(self, first=10,
                         second=self.guardian.adjust_amount(10, structure_resources, structure_limits))</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_check_invalid_values"><code class="name flex">
<span>def <span class="ident">test_check_invalid_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_check_invalid_values(self):

    # An error should be thrown
    with self.assertRaises(ValueError):
        self.guardian.check_invalid_values(20, &#34;label1&#34;, 10, &#34;label2&#34;)

    # Nothing should happen
    TestCase.assertEqual(self, first=None, second=self.guardian.check_invalid_values(10, &#34;label1&#34;, 20, &#34;label2&#34;))</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_check_unset_values"><code class="name flex">
<span>def <span class="ident">test_check_unset_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_check_unset_values(self):
    # An error should be thrown
    with self.assertRaises(ValueError):
        self.guardian.check_unset_values(NOT_AVAILABLE_STRING, &#34;min&#34;, &#34;cpu&#34;)

        # Nothing should happen
        self.guardian.check_unset_values(1, &#34;min&#34;, &#34;cpu&#34;)</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_container_energy_str"><code class="name flex">
<span>def <span class="ident">test_container_energy_str</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_container_energy_str(self):
    resources_dict = dict(
        energy=dict(max=50, usage=20, min=0)
    )

    TestCase.assertEqual(self, first=&#34;50,20,0&#34;, second=self.guardian.get_container_energy_str(resources_dict))</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_correct_container_state"><code class="name flex">
<span>def <span class="ident">test_correct_container_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_correct_container_state(self):
    def get_valid_state():
        resources_dict = dict(
            cpu=dict(max=300, current=170, min=50),
            mem=dict(max=8192, current=4096, min=256)
        )

        limits_dict = dict(
            cpu=dict(upper=140, lower=110, boundary=30),
            mem=dict(upper=3072, lower=2048, boundary=1024)

        )
        return resources_dict, limits_dict

    # State should be valid
    resources, limits = get_valid_state()
    TestCase.assertEqual(self, first=limits,
                         second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

    # Make resources and limits invalid because invalid boundary
    for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
        resources, limits = get_valid_state()
        # Upper too close to current
        limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - int(limits[resource][&#34;boundary&#34;] / 2)
        TestCase.assertEqual(self, first=limits,
                             second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

        # Upper too far away to current
        limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - limits[resource][&#34;boundary&#34;] * 2
        TestCase.assertEqual(self, first=limits,
                             second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

        # Lower too close to upper
        limits[resource][&#34;lower&#34;] = limits[resource][&#34;upper&#34;] - int(limits[resource][&#34;boundary&#34;] / 2)
        TestCase.assertEqual(self, first=limits,
                             second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))

        # Lower too far away to upper
        limits[resource][&#34;lower&#34;] = limits[resource][&#34;upper&#34;] - limits[resource][&#34;boundary&#34;] * 2
        TestCase.assertEqual(self, first=limits,
                             second=self.guardian.adjust_container_state(resources, limits, [&#34;cpu&#34;, &#34;mem&#34;]))</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_filter_old_events"><code class="name flex">
<span>def <span class="ident">test_filter_old_events</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_filter_old_events(self):
    all_events = list()
    timeout = 20

    for i in range(0, 5):
        now = time.time()
        ago = now - timeout - 4
        all_events.append({&#34;timestamp&#34;: now})
        all_events.append({&#34;timestamp&#34;: ago})

    valid, invalid = self.guardian.sort_events(all_events, timeout)

    TestCase.assertEqual(self, first=5, second=len(invalid))
    TestCase.assertEqual(self, first=5, second=len(valid))</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_generate_event_name"><code class="name flex">
<span>def <span class="ident">test_generate_event_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_generate_event_name(self):
    scale_down = {&#34;scale&#34;: {&#34;down&#34;: 5}}
    scale_up = {&#34;scale&#34;: {&#34;up&#34;: 2}}

    TestCase.assertEqual(self, first=&#34;CpuUnderuse&#34;, second=generate_event_name(scale_down, &#34;cpu&#34;))
    TestCase.assertEqual(self, first=&#34;MemUnderuse&#34;, second=generate_event_name(scale_down, &#34;mem&#34;))
    TestCase.assertEqual(self, first=&#34;DiskUnderuse&#34;, second=generate_event_name(scale_down, &#34;disk&#34;))
    TestCase.assertEqual(self, first=&#34;NetUnderuse&#34;, second=generate_event_name(scale_down, &#34;net&#34;))

    TestCase.assertEqual(self, first=&#34;CpuBottleneck&#34;, second=generate_event_name(scale_up, &#34;cpu&#34;))
    TestCase.assertEqual(self, first=&#34;MemBottleneck&#34;, second=generate_event_name(scale_up, &#34;mem&#34;))
    TestCase.assertEqual(self, first=&#34;DiskBottleneck&#34;, second=generate_event_name(scale_up, &#34;disk&#34;))
    TestCase.assertEqual(self, first=&#34;NetBottleneck&#34;, second=generate_event_name(scale_up, &#34;net&#34;))

    scale_invalid1 = {&#34;bogus&#34;: 1}
    scale_invalid2 = {&#34;scale&#34;: {&#34;bogus&#34;: 1}}

    with self.assertRaises(ValueError):
        generate_event_name(scale_invalid1, &#34;cpu&#34;)

    with self.assertRaises(ValueError):
        generate_event_name(scale_invalid2, &#34;cpu&#34;)</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_get_amount_from_fit_reduction"><code class="name flex">
<span>def <span class="ident">test_get_amount_from_fit_reduction</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_amount_from_fit_reduction(self):
    current_resource_limit = 2000
    current_resource_usage = 700
    boundary = 500

    # To properly fit the limit, the usage (700) has to be placed between the upper and lower limit,
    # keeping the inter-limit boundary (500) so the new limits should be (950,450)
    # finally, keeping the real resource limit to the upper limit boundary (500), the final
    # current value to apply should be (upper limit)950 + 500(boundary) = 1450
    # so the amount to reduce is 2000 - 1450 = 550
    TestCase.assertEqual(self,
                         first=self.guardian.get_amount_from_fit_reduction(current_resource_limit, boundary,
                                                                           current_resource_usage),
                         second=-550)</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_get_amount_from_percentage_reduction"><code class="name flex">
<span>def <span class="ident">test_get_amount_from_percentage_reduction</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_amount_from_percentage_reduction(self):
    resource = &#34;mem&#34;
    structure = {&#34;resources&#34;: {&#34;mem&#34;: {&#34;max&#34;: 4096, &#34;min&#34;: 280, &#34;current&#34;: 2000}}}
    usages = {&#34;structure.mem.usage&#34;: 700}

    TestCase.assertEqual(self, first=-260,
                         second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 20))
    TestCase.assertEqual(self, first=-520,
                         second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 40))

    TestCase.assertEqual(self, first=-650,
                         second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 50))

    # Should max out at 50%
    TestCase.assertEqual(self, first=-650,
                         second=self.guardian.get_amount_from_percentage_reduction(structure, usages, resource, 70))</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_get_amount_from_proportional_energy_rescaling"><code class="name flex">
<span>def <span class="ident">test_get_amount_from_proportional_energy_rescaling</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_amount_from_proportional_energy_rescaling(self):
    resource = &#34;energy&#34;

    def check():
        data = structure[&#34;resources&#34;][&#34;energy&#34;]
        expected = (data[&#34;max&#34;] - data[&#34;usage&#34;]) * CPU_SHARES_PER_WATT
        TestCase.assertEqual(self, first=expected,
                             second=self.guardian.get_amount_from_proportional_energy_rescaling(structure,
                                                                                                resource))

    structure = {&#34;resources&#34;: {&#34;energy&#34;: {&#34;max&#34;: 60, &#34;min&#34;: 10, &#34;usage&#34;: 30}}}
    check()
    structure = {&#34;resources&#34;: {&#34;energy&#34;: {&#34;max&#34;: 60, &#34;min&#34;: 10, &#34;usage&#34;: 80}}}
    check()</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_get_container_resources_str"><code class="name flex">
<span>def <span class="ident">test_get_container_resources_str</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_container_resources_str(self):

    resources_dict = dict(
        cpu=dict(max=300, current=200, min=50),
        mem=dict(max=8192, current=2048, min=256),
        disk=dict(max=200, current=80, min=50),
        net=dict(max=200, current=80, min=50)
    )

    limits_dict = dict(
        cpu=dict(upper=140, lower=70, boundary=70),
        mem=dict(upper=8000, lower=7000, boundary=1000),
        disk=dict(upper=70, lower=60),
        net=dict(upper=70, lower=60)
    )

    usages_dict = {
        &#34;structure.cpu.usage&#34;: 22.5664364,
        &#34;structure.mem.usage&#34;: 2341.9734,
    }

    TestCase.assertEqual(self, first=&#34;300,200,140,22.57,70,50&#34;,
                         second=self.guardian.get_resource_summary(&#34;cpu&#34;, resources_dict, limits_dict,
                                                                   usages_dict))
    TestCase.assertEqual(self, first=&#34;8192,2048,8000,2341.97,7000,256&#34;,
                         second=self.guardian.get_resource_summary(&#34;mem&#34;, resources_dict, limits_dict,
                                                                   usages_dict))</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_invalid_container_state"><code class="name flex">
<span>def <span class="ident">test_invalid_container_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_invalid_container_state(self):
    def get_valid_state():
        resources_dict = dict(
            cpu=dict(max=300, current=170, min=50),
            mem=dict(max=8192, current=4096, min=256)
        )

        limits_dict = dict(
            cpu=dict(upper=140, lower=110, boundary=30),
            mem=dict(upper=3072, lower=2048, boundary=1024)

        )
        return resources_dict, limits_dict

    # State should be valid
    resources, limits = get_valid_state()
    for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
        self.assertFalse(self.guardian.check_invalid_container_state(resources, limits, resource))

    # Make resources and limits invalid because unset
    for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
        for key in [(&#34;max&#34;, &#34;resource&#34;), (&#34;min&#34;, &#34;resource&#34;), (&#34;upper&#34;, &#34;limit&#34;), (&#34;lower&#34;, &#34;limit&#34;)]:
            label, doc_type = key
            resources, limits = get_valid_state()
            if doc_type == &#34;limit&#34;:
                limits[resource][label] = NOT_AVAILABLE_STRING
            if doc_type == &#34;resource&#34;:
                resources[resource][label] = NOT_AVAILABLE_STRING
            with self.assertRaises(ValueError):
                self.guardian.check_invalid_container_state(resources, limits, resource)

    for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
        # Invalid because max &lt; current
        resources, limits = get_valid_state()
        resources[resource][&#34;max&#34;], resources[resource][&#34;current&#34;] = \
            resources[resource][&#34;current&#34;], resources[resource][&#34;max&#34;]
        with self.assertRaises(ValueError):
            self.guardian.check_invalid_container_state(resources, limits, resource)

        # Invalid because current &lt; upper
        resources, limits = get_valid_state()
        resources[resource][&#34;current&#34;], limits[resource][&#34;upper&#34;] = \
            limits[resource][&#34;upper&#34;], resources[resource][&#34;current&#34;]
        with self.assertRaises(ValueError):
            self.guardian.check_invalid_container_state(resources, limits, resource)

        # Invalid because upper &lt; lower
        resources, limits = get_valid_state()
        limits[resource][&#34;upper&#34;], limits[resource][&#34;lower&#34;] = limits[resource][&#34;lower&#34;], limits[resource][&#34;upper&#34;]
        with self.assertRaises(ValueError):
            self.guardian.check_invalid_container_state(resources, limits, resource)

        # Invalid because lower &lt; min
        # TODO Test deactivated, see TODO in tested function
        # resources, limits = get_valid_state()
        # resources[resource][&#34;min&#34;], limits[resource][&#34;lower&#34;] = \
        #     limits[resource][&#34;lower&#34;], resources[resource][&#34;min&#34;]
        # with self.assertRaises(ValueError):
        #     self.guardian.check_invalid_container_state(resources, limits, resource)

    # Make resources and limits invalid because invalid boundary
    for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
        resources, limits = get_valid_state()
        # Upper too close to current
        limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - int(limits[resource][&#34;boundary&#34;] / 2)
        with self.assertRaises(ValueError):
            self.guardian.check_invalid_container_state(resources, limits, resource)
        # Upper too far away to current
        limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - limits[resource][&#34;boundary&#34;] * 2
        with self.assertRaises(ValueError):
            self.guardian.check_invalid_container_state(resources, limits, resource)</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_match_rules_and_events"><code class="name flex">
<span>def <span class="ident">test_match_rules_and_events</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_match_rules_and_events(self):

    def get_valid_state():
        st = {
            &#34;guard&#34;: True,
            &#34;guard_policy&#34;: &#34;serverless&#34;,
            &#34;host&#34;: &#34;c14-13&#34;,
            &#34;host_rescaler_ip&#34;: &#34;c14-13&#34;,
            &#34;host_rescaler_port&#34;: &#34;8000&#34;,
            &#34;name&#34;: &#34;node0&#34;,
            &#34;resources&#34;: {
                &#34;cpu&#34;: {
                    &#34;current&#34;: 140,
                    &#34;guard&#34;: True,
                    &#34;max&#34;: 200,
                    &#34;min&#34;: 50
                },
                &#34;energy&#34;: {
                    &#34;guard&#34;: False,
                    &#34;max&#34;: 20,
                    &#34;min&#34;: 0,
                    &#34;usage&#34;: 2.34
                },
                &#34;mem&#34;: {
                    &#34;current&#34;: 3072,
                    &#34;guard&#34;: True,
                    &#34;max&#34;: 10240,
                    &#34;min&#34;: 512
                }
            },
            &#34;subtype&#34;: &#34;container&#34;,
            &#34;type&#34;: &#34;structure&#34;
        }
        lim = {&#34;cpu&#34;: {&#34;upper&#34;: 120, &#34;lower&#34;: 80, &#34;boundary&#34;: 20},
               &#34;mem&#34;: {&#34;upper&#34;: 2048, &#34;lower&#34;: 1024, &#34;boundary&#34;: 1024},
               &#34;energy&#34;: {&#34;upper&#34;: 20, &#34;lower&#34;: 10, &#34;boundary&#34;: 5},
               }

        us = {&#34;structure.cpu.usage&#34;: 100, &#34;structure.mem.usage&#34;: 1536, &#34;structure.energy.usage&#34;: 15}

        return st, lim, us

    event_rules = [cpu_exceeded_upper, cpu_dropped_lower, mem_exceeded_upper, mem_dropped_lower,
                   energy_exceeded_upper, energy_dropped_lower]
    rescaling_rules = [CpuRescaleUp, CpuRescaleDown, MemRescaleUp, MemRescaleDown, EnergyRescaleUp,
                       EnergyRescaleDown]
    for rule in event_rules + rescaling_rules:
        rule[&#34;active&#34;] = True

    for tuple in [(&#34;cpu&#34;, CpuRescaleDown, -50), (&#34;mem&#34;, MemRescaleDown, -50), (&#34;cpu&#34;, CpuRescaleUp, 100),
                  (&#34;mem&#34;, MemRescaleUp, 2034)]:

        resource, rescale_rule, amount = tuple
        structure, limits, usages = get_valid_state()

        usages[&#34;structure.&#34; + resource + &#34;.usage&#34;] = limits[resource][&#34;lower&#34;] + amount
        events = list()

        num_needed_events = rescale_rule[&#34;rule&#34;][&#34;and&#34;][0][&#34;&gt;=&#34;][1]

        for i in range(num_needed_events):
            events += self.guardian.match_usages_and_limits(structure[&#34;name&#34;], event_rules, usages, limits,
                                                            structure[&#34;resources&#34;])
        events = self.guardian.reduce_structure_events(events)

        generated_requests, events_to_remove = self.guardian.match_rules_and_events(structure, rescaling_rules,
                                                                                    events, limits,
                                                                                    usages)

        expected_events_to_remove = dict()
        event_to_remove_name = MyUtils.generate_event_name(events[resource][&#34;events&#34;], resource)
        expected_events_to_remove[event_to_remove_name] = num_needed_events

        TestCase.assertEqual(self, first=expected_events_to_remove, second=events_to_remove)</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_match_usages_and_limits"><code class="name flex">
<span>def <span class="ident">test_match_usages_and_limits</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_match_usages_and_limits(self):
    def assert_event_equals(rule, ev):
        event_expected_name = generate_event_name(rule[&#34;action&#34;][&#34;events&#34;], rule[&#34;resource&#34;])
        self.assertTrue(event_expected_name, ev[&#34;name&#34;])
        self.assertTrue(structure_name, ev[&#34;structure&#34;])
        self.assertTrue(rule[&#34;action&#34;], ev[&#34;action&#34;])
        self.assertTrue(&#34;event&#34;, ev[&#34;type&#34;])
        self.assertTrue(rule[&#34;resource&#34;], ev[&#34;resource&#34;])

    mem_exceeded_upper[&#34;active&#34;] = True
    mem_dropped_lower[&#34;active&#34;] = True

    rules = [mem_exceeded_upper, mem_dropped_lower]
    structure_name = &#34;node99&#34;

    resources = dict(
        mem=dict(max=8192, current=4096, min=256, guard=True),
    )

    limits = dict(
        mem=dict(upper=2048, lower=1024),
    )
    usages = {&#34;structure.mem.usage&#34;: 1536}

    # No events expected
    TestCase.assertEqual(self, [],
                         second=self.guardian.match_usages_and_limits(structure_name, rules, usages, limits,
                                                                      resources))

    # Expect mem underuse event
    usages[&#34;structure.mem.usage&#34;] = limits[&#34;mem&#34;][&#34;lower&#34;] - 100
    events = self.guardian.match_usages_and_limits(structure_name, rules, usages, limits, resources)
    if not events:
        self.fail(&#34;No events were triggered when expected.&#34;)
    else:
        event = events[0]
        assert_event_equals(mem_dropped_lower, event)

    # Expect mem bottleneck event
    usages[&#34;structure.mem.usage&#34;] = limits[&#34;mem&#34;][&#34;upper&#34;] + 100
    events = self.guardian.match_usages_and_limits(structure_name, rules, usages, limits, resources)
    if not events:
        self.fail(&#34;No events were triggered when expected.&#34;)
    else:
        event = events[0]
        assert_event_equals(mem_dropped_lower, event)</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_reduce_structure_events"><code class="name flex">
<span>def <span class="ident">test_reduce_structure_events</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_reduce_structure_events(self):
    input_events = list()
    for i in range(1, 5):
        input_events.append({&#34;resource&#34;: &#34;cpu&#34;, &#34;action&#34;: {&#34;events&#34;: {&#34;scale&#34;: {&#34;up&#34;: i, &#34;down&#34;: 0}}}})

    for i in range(2, 6):
        input_events.append({&#34;resource&#34;: &#34;cpu&#34;, &#34;action&#34;: {&#34;events&#34;: {&#34;scale&#34;: {&#34;up&#34;: 0, &#34;down&#34;: i}}}})

    expected_output = {&#34;cpu&#34;: {&#34;events&#34;: {&#34;scale&#34;: {&#34;up&#34;: sum(range(1, 5)), &#34;down&#34;: sum(range(2, 6))}}}}

    TestCase.assertEqual(self, first=expected_output, second=self.guardian.reduce_structure_events(input_events))</code></pre>
</details>
</dd>
<dt id="src.Guardian.testGuardian.GuardianTest.test_try_get_value"><code class="name flex">
<span>def <span class="ident">test_try_get_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_try_get_value(self):
    TestCase.assertEqual(self, first=1, second=self.guardian.try_get_value({&#34;KEY&#34;: 1}, &#34;KEY&#34;))
    TestCase.assertEqual(self, first=NOT_AVAILABLE_STRING,
                         second=self.guardian.try_get_value({&#34;KEY&#34;: 1}, &#34;NOKEY&#34;))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href="http://bdwatchdog.dec.udc.es/ServerlessContainers/docs_web/index.html"><img src="https://s3-eu-west-1.amazonaws.com/jonatan.enes.udc/serverless_containers_website/logo_serverless.png" style="height:100px;"/></a>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.Guardian" href="index.html">src.Guardian</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.Guardian.testGuardian.GuardianServelerssIntegrationTest" href="#src.Guardian.testGuardian.GuardianServelerssIntegrationTest">GuardianServelerssIntegrationTest</a></code></h4>
<ul class="">
<li><code><a title="src.Guardian.testGuardian.GuardianServelerssIntegrationTest.setUp" href="#src.Guardian.testGuardian.GuardianServelerssIntegrationTest.setUp">setUp</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianServelerssIntegrationTest.tearDown" href="#src.Guardian.testGuardian.GuardianServelerssIntegrationTest.tearDown">tearDown</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianServelerssIntegrationTest.test_serverless" href="#src.Guardian.testGuardian.GuardianServelerssIntegrationTest.test_serverless">test_serverless</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.Guardian.testGuardian.GuardianTest" href="#src.Guardian.testGuardian.GuardianTest">GuardianTest</a></code></h4>
<ul class="">
<li><code><a title="src.Guardian.testGuardian.GuardianTest.setUp" href="#src.Guardian.testGuardian.GuardianTest.setUp">setUp</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_adjust_if_invalid_amount" href="#src.Guardian.testGuardian.GuardianTest.test_adjust_if_invalid_amount">test_adjust_if_invalid_amount</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_check_invalid_values" href="#src.Guardian.testGuardian.GuardianTest.test_check_invalid_values">test_check_invalid_values</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_check_unset_values" href="#src.Guardian.testGuardian.GuardianTest.test_check_unset_values">test_check_unset_values</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_container_energy_str" href="#src.Guardian.testGuardian.GuardianTest.test_container_energy_str">test_container_energy_str</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_correct_container_state" href="#src.Guardian.testGuardian.GuardianTest.test_correct_container_state">test_correct_container_state</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_filter_old_events" href="#src.Guardian.testGuardian.GuardianTest.test_filter_old_events">test_filter_old_events</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_generate_event_name" href="#src.Guardian.testGuardian.GuardianTest.test_generate_event_name">test_generate_event_name</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_get_amount_from_fit_reduction" href="#src.Guardian.testGuardian.GuardianTest.test_get_amount_from_fit_reduction">test_get_amount_from_fit_reduction</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_get_amount_from_percentage_reduction" href="#src.Guardian.testGuardian.GuardianTest.test_get_amount_from_percentage_reduction">test_get_amount_from_percentage_reduction</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_get_amount_from_proportional_energy_rescaling" href="#src.Guardian.testGuardian.GuardianTest.test_get_amount_from_proportional_energy_rescaling">test_get_amount_from_proportional_energy_rescaling</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_get_container_resources_str" href="#src.Guardian.testGuardian.GuardianTest.test_get_container_resources_str">test_get_container_resources_str</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_invalid_container_state" href="#src.Guardian.testGuardian.GuardianTest.test_invalid_container_state">test_invalid_container_state</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_match_rules_and_events" href="#src.Guardian.testGuardian.GuardianTest.test_match_rules_and_events">test_match_rules_and_events</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_match_usages_and_limits" href="#src.Guardian.testGuardian.GuardianTest.test_match_usages_and_limits">test_match_usages_and_limits</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_reduce_structure_events" href="#src.Guardian.testGuardian.GuardianTest.test_reduce_structure_events">test_reduce_structure_events</a></code></li>
<li><code><a title="src.Guardian.testGuardian.GuardianTest.test_try_get_value" href="#src.Guardian.testGuardian.GuardianTest.test_try_get_value">test_try_get_value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<!--Grid row-->
<div class="row">
<div class="footer_image">
<a href="http://gac.udc.es/english/">
<img src="https://s3-eu-west-1.amazonaws.com/jonatan.enes.udc/serverless_containers_website/footer/logotipoingles.png"
class="img-fluid" alt="">
<div class="mask rgba-white-light"></div>
</a>
</div>
<div class="footer_image">
<a href="http://www.mineco.gob.es">
<img src="https://s3-eu-west-1.amazonaws.com/jonatan.enes.udc/serverless_containers_website/footer/mineco.jpg"
class="img-fluid" alt="">
<div class="mask rgba-white-light"></div>
</a>
</div>
<div class="footer_image">
<img src="https://s3-eu-west-1.amazonaws.com/jonatan.enes.udc/serverless_containers_website/footer/feder.jpg"
class="img-fluid" alt="">
</div>
<div class="footer_image">
<a href="http://www.udc.es/index.html?language=en">
<img src="https://s3-eu-west-1.amazonaws.com/jonatan.enes.udc/serverless_containers_website/footer/03_Simbolo_logo_cor.png"
class="img-fluid" alt="">
<div class="mask rgba-white-light"></div>
</a>
</div>
</div>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>